package routehelper

import (
	"fmt"
	"go/format"
	"os"
	"strings"
	"text/template"
)

// RouteInfo holds metadata about a route for code generation
type RouteInfo struct {
	Name       string
	Pattern    string
	Method     string
	Parameters []RouteParam
}

// RouteParam represents a parameter in a route
type RouteParam struct {
	Name string
	Type string // "string", "int", etc.
}

// Generator generates type-safe route helper functions
type Generator struct {
	routes []RouteInfo
}

// New creates a new route helper generator instance
func New() *Generator {
	return &Generator{
		routes: make([]RouteInfo, 0),
	}
}

// AddRoute registers a route for code generation
func (g *Generator) AddRoute(name, pattern, method string) {
	params := extractParameters(pattern)
	g.routes = append(g.routes, RouteInfo{
		Name:       name,
		Pattern:    pattern,
		Method:     method,
		Parameters: params,
	})
}

// extractParameters parses route pattern and extracts parameter info
func extractParameters(pattern string) []RouteParam {
	parts := strings.Split(strings.Trim(pattern, "/"), "/")
	params := make([]RouteParam, 0)

	for _, part := range parts {
		if strings.HasPrefix(part, ":") {
			paramName := strings.TrimPrefix(part, ":")
			// Default to string, could be enhanced with type hints
			params = append(params, RouteParam{
				Name: paramName,
				Type: "string",
			})
		}
	}

	return params
}

// Generate creates the Go source file with route helpers
func (g *Generator) Generate(packageName, outputFile string) error {
	// If no routes exist, remove the generated file if it exists
	if len(g.routes) == 0 {
		if _, err := os.Stat(outputFile); err == nil {
			// File exists, remove it
			return os.Remove(outputFile)
		}
		// File doesn't exist, nothing to do
		return nil
	}

	// Check if any route has parameters
	hasParams := false
	for _, route := range g.routes {
		if len(route.Parameters) > 0 {
			hasParams = true
			break
		}
	}

	tmpl := template.Must(template.New("routes").Funcs(template.FuncMap{
		"camelCase":  toCamelCase,
		"paramList":  makeParamList,
		"paramNames": makeParamNames,
		"hasParams":  func() bool { return hasParams },
	}).Parse(routeTemplate))

	data := struct {
		Package   string
		Routes    []RouteInfo
		HasParams bool
	}{
		Package:   packageName,
		Routes:    g.routes,
		HasParams: hasParams,
	}

	var builder strings.Builder
	if err := tmpl.Execute(&builder, data); err != nil {
		return fmt.Errorf("template execution failed: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source([]byte(builder.String()))
	if err != nil {
		return fmt.Errorf("formatting failed: %w", err)
	}

	// Write to file
	return os.WriteFile(outputFile, formatted, 0644)
}

// Helper functions for template
func toCamelCase(s string) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || r == ' '
	})
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

func makeParamList(params []RouteParam) string {
	if len(params) == 0 {
		return ""
	}

	parts := make([]string, len(params))
	for i, p := range params {
		parts[i] = fmt.Sprintf("%s %s", p.Name, p.Type)
	}
	return strings.Join(parts, ", ")
}

func makeParamNames(params []RouteParam) string {
	if len(params) == 0 {
		return ""
	}

	names := make([]string, len(params))
	for i, p := range params {
		names[i] = p.Name
	}
	return strings.Join(names, ", ")
}

// Template for generated code
const routeTemplate = `// Code generated by router path helper generator. DO NOT EDIT.
package {{.Package}}

import (
	"net/url"
{{- if .HasParams}}
	"strings"
{{- end}}
)

{{range .Routes}}
// {{camelCase .Name}}Path generates a path for the {{.Name}} route
// Route: {{.Method}} {{.Pattern}}
// Optional query parameters can be passed as the last argument
func {{camelCase .Name}}Path({{paramList .Parameters}}{{if .Parameters}}, {{end}}query ...url.Values) string {
{{- if .Parameters}}
	path := "{{.Pattern}}"
	{{range .Parameters -}}
	path = strings.Replace(path, ":{{.Name}}", {{.Name}}, 1)
	{{end -}}
{{- else}}
	path := "{{.Pattern}}"
{{- end}}
	if len(query) > 0 && len(query[0]) > 0 {
		path += "?" + query[0].Encode()
	}
	return path
}

// {{camelCase .Name}}URL generates a full URL for the {{.Name}} route
// Optional query parameters can be passed as the last argument
func {{camelCase .Name}}URL(host string{{if .Parameters}}, {{paramList .Parameters}}{{end}}, query ...url.Values) string {
	return host + {{camelCase .Name}}Path({{paramNames .Parameters}}{{if .Parameters}}, {{end}}query...)
}
{{end}}
`
